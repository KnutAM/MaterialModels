!DEC$ FREEFORM
!   Special umat for running taylor assumption over multiple local directions
!   The last material parameter is used to set the number of directions. The remaining are according to the orientation dependent (od) material model
!   Note:   Only the deformation gradient is rotated before (hence we cannot rely on previous stress or strain values in the od material model)
!           On output, the stress and the stiffness ddsdde are rotated back
!
!   ======  Start of constant umat header (Knut Andreas)  ========
!   Variables that always should be updated
!   stress      [1 x ntens]     stress tensor at beginning of increment, to be updated
!   statev      [1 x nstatv]    Array of solution dependent state variables, to be updated (and rotated using drot)
!   ddsdde      [ntens x ntens] The jacobian dsigma/epsilon. 
!   sse         [1]             Specific elastic strain energy
!   spd         [1]             Specific plastic dissipation
!   scd         [1]             Specific creep dissipation
!
!   Variables that should only be updated in fully coupled thermal-stress analysis
!   rpl         [1]             Volumetric heat generation per unit time at the end of increment (see guide if geostatic pores)
!   ddsddt      [1 x ntens]     Variation of the stress increments with respect to temperature
!   drplde      [1 x ntens]     Variation of rpl with respect to the strain increments
!   drpldt      [1]             Variation of rpl with respect to temperature
!     
!   Variables passed for information (DO NOT CHANGE)
!   stran       [1 x ntens]     Strains at the beginning of the increment. Strain components rotated to account for RBM before UMAT call
!   dstran      [1 x ntens]     Strain increments
!   time        [1 x 2]         Value of [step time, total time] at the beginning of the current increment
!   dtime       [1]             Time increment
!   temp        [1]             Temperature at the start of the increment
!   dtemp       [1]             Increment of temperature
!   predef      [1 x ?]         Array of interpolated values of predefined field variables at this point at the start of the increment
!   dpred       [1 x ?]         Array of increments of predefined field variables
!   cmname      [string]        User-defined material name, left justified. 
!   ndi         [int]           Number of direct stress components at this point
!   nshr        [int]           Number of engineering shear stress components at this point
!   ntens       [int]           Size of the stress or strain component array (ndi + nshr)
!   nstatv      [int]           Number of solution-dependent state variables that are associated with this material type
!   props       [1 x nprops]    User-specified array of material constants associated with this user material
!   nprops      [int]           User-defined number of material constants associated with this user material
!   coords      [1 x 3]         An array containing the coordinates of this point. 
!   drot        [3 x 3]         Rotation increment matrix
!   pnewdt      [1]             CAN BE CHANGED: Ratio of suggested new time increment to the time increment being used
!   celent      [1]             Characteristic element length
!   dfgrd0      [3,3]           Deformation gradient at the beginning of the increment
!   dfgrd1      [3,3]           Deformation gradient at the end of the increment
!   noel        [int]           Element number
!   npt         [int]           Integration point number
!   layer       [int]           Layer number (for composite shells and layered solids)
!   kspt        [int]           Section point number within the current layer
!   kstep       [int]           Step number
!   kinc        [int]           Increment number
! 
 
! To compile for abaqus, remove comments on smsutility, umat_module. 
! Also comment out "!DEC$ ATTRIBUTES DLLEXPORT :: UMAT" by adding another exclamation mark in front. 
    
!include '../../umat_utils/smsutility.f90'          ! Required for AceGen code 
!include 'Cruzado2015.f90'                      ! Particular model functions generated by AceGen
!include '../../umat_utils/SolveMatrixEquation.f90' ! Solving of nonlinear matrix equation system
!include 'umat_module.f90'                          ! Support function for this umat

SUBROUTINE UMAT(stress,statev,ddsdde,sse,spd,scd, &
rpl,ddsddt,drplde,drpldt,&
stran,dstran,time,dtime,temp,dtemp,predef,dpred,cmname,&
ndi,nshr,ntens,nstatv,props,nprops,coords,drot,pnewdt,&
celent,dfgrd0,dfgrd1,noel,npt,layer,kspt,kstep,kinc)
!DEC$ ATTRIBUTES DLLEXPORT :: UMAT
use crystal_orientations_mod
implicit none
!
character*80 cmname
integer:: ndi,nshr,ntens,nstatv,nprops,noel,npt,&
layer, kspt, kstep, kinc
double precision:: dtime,temp,dtemp,pnewdt,celent,sse,spd,scd,rpl,drpldt
double precision:: stress(ntens),statev(nstatv),&
ddsdde(ntens,ntens),ddsddt(ntens),drplde(ntens),&
stran(ntens),dstran(ntens),time(2),predef(1),dpred(1),&
props(nprops),coords(3),drot(3,3),dfgrd0(3,3),dfgrd1(3,3)
! End of default parameters
double precision                :: stressi(6), ddsddei(6,6), stress_tmp(6), ddsdde_tmp(6,6), dfgrd1_rot(3,3)
integer                         :: num_systems, k1, sub_nstatv, statev_ind
logical                         :: num_ok
double precision, allocatable   :: qrot(:,:), sub_statev(:)
double precision, dimension(6)  :: ddsddt6, drplde6,stran6,dstran6

num_systems = props(nprops)
if (num_systems>1) then
    call get_rotation_matrices(num_systems, qrot, num_ok)
endif
sub_nstatv = nstatv/num_systems
allocate(sub_statev(sub_nstatv))

ddsddei = 0.d0
stressi = 0.d0

do k1=1,num_systems
    ! Prepare input before calling umat
    if (k1>1) then
        call rotate_input(dfgrd1, dfgrd1_rot, qrot(:, k1-1))
    else
        dfgrd1_rot = dfgrd1
    endif
    statev_ind = 1 + (k1-1)*sub_nstatv ! Index of first sub state variable
    sub_statev = statev(statev_ind:(statev_ind+sub_nstatv-1)) ! The sub state variables
    
    ! Call umat_local_orientation
    call umat_local_orientation(stress_tmp,sub_statev,ddsdde_tmp,sse,spd,scd, &
                                rpl,ddsddt6,drplde6,drpldt,&
                                stran6,dstran6,time,dtime,temp,dtemp,predef,dpred,cmname,&
                                3,3,6,sub_nstatv,props,nprops-1,coords,drot,pnewdt,&
                                celent,dfgrd0,dfgrd1_rot,noel,npt,layer,kspt,kstep,kinc)

    ! Check for local convergence, suffices that one doesn't converge for entire simulation to fail and then it is better to stop directly
    if (pnewdt<1.0) then
        exit
    endif
    
    ! Rotate output
    if (k1>1) then
        call rotate_output(stress_tmp, ddsdde_tmp, qrot(:, k1-1))
    endif
    
    ! Add contributions to averaging
    stressi = stressi + stress_tmp
    ddsddei = ddsddei + ddsdde_tmp
    
    ! Save back updated state variables
    statev(statev_ind:(statev_ind+sub_nstatv-1)) = sub_statev
    
enddo

stress = stressi(1:ntens)/num_systems
ddsdde = ddsddei(1:ntens, 1:ntens)/num_systems

sse = sse/num_systems
spd = spd/num_systems
scd = scd/num_systems
rpl = rpl/num_systems

END SUBROUTINE